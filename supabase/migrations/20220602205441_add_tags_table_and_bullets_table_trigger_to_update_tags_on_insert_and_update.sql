-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.update_user_tags()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
declare
    -- variables
    var_tags     json;
    var_tag_data json;
begin
    -- select the tags of the bullet
    select b.tags
    into var_tags
    from bullets as b
    where b.id = NEW.id
      and b.user_id = NEW.user_id;
    -- insert bullets into

    for var_tag_data in select * from json_array_elements(var_tags)
        loop
            insert into tags (user_id, tag, bullets)
            VALUES (NEW.user_id, var_tag_data ->> 'tag', array [NEW.id])
            on conflict on constraint tags_pkey
                do update set bullets = ARRAY(select distinct unnest(array_append(tags.bullets, NEW.id)));
        end loop;

    return NEW;

end;
$BODY$;

ALTER FUNCTION public.update_user_tags()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.update_user_tags() TO authenticated;

GRANT EXECUTE ON FUNCTION public.update_user_tags() TO postgres;

GRANT EXECUTE ON FUNCTION public.update_user_tags() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.update_user_tags() TO anon;

GRANT EXECUTE ON FUNCTION public.update_user_tags() TO service_role;

CREATE TABLE IF NOT EXISTS public.tags
(
    user_id uuid NOT NULL,
    tag character varying COLLATE pg_catalog."default" NOT NULL,
    bullets uuid[],
    CONSTRAINT tags_pkey PRIMARY KEY (user_id, tag),
    CONSTRAINT tags_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.tags
    OWNER to postgres;

ALTER TABLE IF EXISTS public.tags
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.tags TO anon;

GRANT ALL ON TABLE public.tags TO authenticated;

GRANT ALL ON TABLE public.tags TO postgres;

GRANT ALL ON TABLE public.tags TO service_role;
CREATE POLICY "Users can select their tags"
    ON public.tags
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "users can delete their own tags"
    ON public.tags
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "users can insert tags only with their own user id"
    ON public.tags
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = user_id));
CREATE POLICY "users can update their own tags"
    ON public.tags
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = user_id))
    WITH CHECK ((auth.uid() = user_id));

CREATE TRIGGER update_user_tags
    AFTER INSERT OR UPDATE 
    ON public.bullets
    FOR EACH ROW
    EXECUTE FUNCTION public.update_user_tags();
